<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>arel314</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: #000;
            cursor: none;
        }
    </style>
</head>
<body>
    <canvas id="gridCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true 
        });
        
        const isMobile = window.innerWidth < 768;
        let mousePos = { x: -1000, y: -1000 };
        let dots = [];
        let seeds = [];
        let textElements = [];
        let waves = []; // Active click waves
        let animationId = null;
        let lastFrameTime = 0;
        let isHovering = false;
        
        const globalScaleFactor = isMobile ? 3 : 1.5;
        const SPACING = 20 / globalScaleFactor;
        const PUSH_RADIUS = 1000 / globalScaleFactor;
        const PUSH_RADIUS_SQ = PUSH_RADIUS * PUSH_RADIUS;
        const MAX_SEED_INFLUENCE = 800 / globalScaleFactor;
        const CROSS_SIZE = 5 / globalScaleFactor;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initializeDots();
            initializeText();
            if (seeds.length === 0) {
                initializeSeeds();
            }
        }
        
        function initializeSeeds() {
            seeds = [];
            for (let i = 0; i < 12; i++) {
                seeds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2.0,
                    vy: (Math.random() - 0.5) * 2.0,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        
        function initializeText() {
            textElements = [];
            const margin = 60 / globalScaleFactor;
            
            // Main title AREL314
            textElements.push({
                text: 'AREL314',
                x: margin,
                y: margin + 80,
                fontSize: isMobile ? 55 : 90,
                font: 'Arial',
                weight: 'bold'
            });
            
            // Email
            textElements.push({
                text: 'arc@arel314.xyz',
                x: margin,
                y: margin + 140,
                fontSize: isMobile ? 14 : 18,
                font: 'Arial',
                weight: 'bold'
            });
            
            // Keywords
            textElements.push({
                text: 'architecture ¬ construct ¬ space ¬ building information',
                x: margin,
                y: margin + 170,
                fontSize: isMobile ? 14 : 18,
                font: 'Arial',
                weight: 'normal'
            });
        }
        
        function initializeDots() {
            dots = [];
            const cols = Math.ceil(canvas.width / SPACING) + 1;
            const rows = Math.ceil(canvas.height / SPACING) + 1;
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const x = i * SPACING;
                    const y = j * SPACING;
                    dots.push({
                        baseX: x,
                        baseY: y,
                        currentX: x,
                        currentY: y
                    });
                }
            }
        }
        
        function getBrightnessAtPoint(x, y, seeds, mouseX, mouseY, isText = false) {
            // Calculate voronoi brightness
            let minSeedDist = Infinity;
            seeds.forEach(seed => {
                const sdx = x - seed.x;
                const sdy = y - seed.y;
                const seedDistSq = sdx * sdx + sdy * sdy;
                if (seedDistSq < minSeedDist) {
                    minSeedDist = seedDistSq;
                }
            });
            minSeedDist = Math.sqrt(minSeedDist);
            const seedInfluence = Math.max(0, 1 - minSeedDist / MAX_SEED_INFLUENCE);
            const ambientBrightness = (isMobile ? 0.1 : 0.1) + (0.4 * seedInfluence);
            
            // Check hover effect
            const dxFromMouse = x - mouseX;
            const dyFromMouse = y - mouseY;
            const distanceSqFromMouse = dxFromMouse * dxFromMouse + dyFromMouse * dyFromMouse;
            
            const applyHoverEffect = isHovering && distanceSqFromMouse < PUSH_RADIUS_SQ && distanceSqFromMouse > 0;
            
            let maxBrightnessBoost = 0;
            
            if (applyHoverEffect) {
                const distance = Math.sqrt(distanceSqFromMouse);
                const t = distance / PUSH_RADIUS;
                const brightnessInfluence = Math.pow(1 - t, 4);
                
                // Both start at 1.0 at edge, but text reaches higher maximum
                const maxBoost = isText ? 6 : 4; // Text: 1.0->7.0, Crosses: 1.0->5.0
                maxBrightnessBoost = maxBoost * brightnessInfluence;
            }
            
            // Check wave effects
            waves.forEach(wave => {
                const dwx = x - wave.x;
                const dwy = y - wave.y;
                const distToWave = Math.sqrt(dwx * dwx + dwy * dwy);
                const distFromWavefront = Math.abs(distToWave - wave.radius);
                const waveWidth = 150 / globalScaleFactor;;
                
                if (distFromWavefront < waveWidth) {
                    const waveInfluence = (1 - distFromWavefront / waveWidth) * wave.intensity;
                    const waveBoost = waveInfluence * (isText ? 6 : 3);
                    maxBrightnessBoost = Math.max(maxBrightnessBoost, waveBoost);
                }
            });
            
            return Math.min(255, Math.floor(ambientBrightness * (1 + maxBrightnessBoost) * 255));
        }
        
        function drawTextWithGradient(element, seeds, mx, my) {
            ctx.font = `${element.weight} ${element.fontSize}px ${element.font}`;
            
            let currentX = element.x;
            
            // Render each character with its own gradient
            for (let i = 0; i < element.text.length; i++) {
                const char = element.text[i];
                const charWidth = ctx.measureText(char).width;
                
                // Sample multiple points across character width
                const samples = 5; // 5 sample points for smooth gradient
                const brightnessValues = [];
                
                for (let s = 0; s < samples; s++) {
                    const sampleX = currentX + (charWidth / (samples - 1)) * s;
                    const sampleY = element.y - element.fontSize / 3; // Sample at middle height of char
                    brightnessValues.push(
                        getBrightnessAtPoint(sampleX, sampleY, seeds, mx, my, true)
                    );
                }
                
                // Create linear gradient from left to right of character
                const gradient = ctx.createLinearGradient(
                    currentX, element.y, 
                    currentX + charWidth, element.y
                );
                
                // Add color stops based on sampled brightness values
                for (let s = 0; s < samples; s++) {
                    const b = brightnessValues[s];
                    const position = s / (samples - 1);
                    gradient.addColorStop(position, `rgba(${b}, ${b}, ${b}, 0.8)`);
                }
                
                ctx.fillStyle = gradient;
                ctx.fillText(char, currentX, element.y);
                
                currentX += charWidth;
            }
        }
        
        function animate(currentTime) {
            const deltaTime = currentTime - lastFrameTime;
            if (deltaTime < 16) {
                animationId = requestAnimationFrame(animate);
                return;
            }
            lastFrameTime = currentTime;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const time = Date.now() * 0.0012;
            seeds.forEach(seed => {
                const wobbleX = Math.sin(time + seed.phase) * (4 / globalScaleFactor);
                const wobbleY = Math.cos(time + seed.phase * 1.3) * (4 / globalScaleFactor);
                
                seed.x += seed.vx + wobbleX;
                seed.y += seed.vy + wobbleY;
                
                if (seed.x < 0 || seed.x > canvas.width) {
                    seed.vx *= -1;
                    seed.vx += (Math.random() - 0.5) * 0.5;
                }
                if (seed.y < 0 || seed.y > canvas.height) {
                    seed.vy *= -1;
                    seed.vy += (Math.random() - 0.5) * 0.5;
                }
                
                seed.x = Math.max(0, Math.min(canvas.width, seed.x));
                seed.y = Math.max(0, Math.min(canvas.height, seed.y));
            });
            
            const mx = mousePos.x;
            const my = mousePos.y;
            
            // Update and clean up waves
            waves = waves.filter(wave => {
                wave.radius += wave.speed;
                wave.intensity *= wave.decay;
                return wave.intensity > 0.01; // Remove weak waves
            });
            
            // Draw grid crosses
            ctx.lineWidth = 1;
            const brightnessBuckets = new Map();
            
            dots.forEach(dot => {
                const dxFromMouse = dot.baseX - mx;
                const dyFromMouse = dot.baseY - my;
                const distanceSqFromMouse = dxFromMouse * dxFromMouse + dyFromMouse * dyFromMouse;
                
                let minSeedDist = Infinity;
                seeds.forEach(seed => {
                    const sdx = dot.baseX - seed.x;
                    const sdy = dot.baseY - seed.y;
                    const seedDistSq = sdx * sdx + sdy * sdy;
                    if (seedDistSq < minSeedDist) {
                        minSeedDist = seedDistSq;
                    }
                });
                minSeedDist = Math.sqrt(minSeedDist);
                const seedInfluence = Math.max(0, 1 - minSeedDist / MAX_SEED_INFLUENCE);
                const ambientBrightness = (isMobile ? 0.1 : 0.1) + (0.4 * seedInfluence);
                
                let brightness;
                const applyHoverEffect = isHovering && distanceSqFromMouse < PUSH_RADIUS_SQ && distanceSqFromMouse > 0;
                
                // Check wave effects
                let waveEffect = { push: 0, brightness: 0 };
                waves.forEach(wave => {
                    const dwx = dot.baseX - wave.x;
                    const dwy = dot.baseY - wave.y;
                    const distToWave = Math.sqrt(dwx * dwx + dwy * dwy);
                    
                    // Wave is a ring: strongest at wavefront
                    const distFromWavefront = Math.abs(distToWave - wave.radius);
                    const waveWidth = 150 / globalScaleFactor; // Width of the wave ring
                    
                    if (distFromWavefront < waveWidth) {
                        const waveInfluence = (1 - distFromWavefront / waveWidth) * wave.intensity;
                        waveEffect.brightness = Math.max(waveEffect.brightness, waveInfluence * 3);
                        
                        // Radial push from wave center
                        const pushInfluence = waveInfluence * 0.5;
                        waveEffect.push = Math.max(waveEffect.push, pushInfluence);
                    }
                });
                
                if (applyHoverEffect || waveEffect.push > 0) {
                    let totalPushX = 0;
                    let totalPushY = 0;
                    let maxBrightnessInfluence = 0;
                    
                    // Mouse hover push
                    if (applyHoverEffect) {
                        const distance = Math.sqrt(distanceSqFromMouse);
                        const t = distance / PUSH_RADIUS;
                        
                        const pushInfluence = Math.pow(1 - t, 1.0);
                        const brightnessInfluence = Math.pow(1 - t, 4);
                        maxBrightnessInfluence = brightnessInfluence;
                        
                        const pushStrength = (40 / globalScaleFactor) * pushInfluence;
                        const angle = Math.atan2(dyFromMouse, dxFromMouse);
                        totalPushX += Math.cos(angle) * pushStrength;
                        totalPushY += Math.sin(angle) * pushStrength;
                    }
                    
                    // Wave push
                    if (waveEffect.push > 0) {
                        waves.forEach(wave => {
                            const dwx = dot.baseX - wave.x;
                            const dwy = dot.baseY - wave.y;
                            const distToWave = Math.sqrt(dwx * dwx + dwy * dwy);
                            const distFromWavefront = Math.abs(distToWave - wave.radius);
                            const waveWidth = 150 / globalScaleFactor;
                            
                            if (distFromWavefront < waveWidth && distToWave > 0) {
                                const waveInfluence = (1 - distFromWavefront / waveWidth) * wave.intensity;
                                const wavePushStrength = (50 / globalScaleFactor) * waveInfluence;
                                const angle = Math.atan2(dwy, dwx);
                                totalPushX += Math.cos(angle) * wavePushStrength;
                                totalPushY += Math.sin(angle) * wavePushStrength;
                            }
                        });
                    }
                    
                    const targetX = dot.baseX + totalPushX;
                    const targetY = dot.baseY + totalPushY;
                    
                    const lerpFactor = 0.3;
                    dot.currentX += (targetX - dot.currentX) * lerpFactor;
                    dot.currentY += (targetY - dot.currentY) * lerpFactor;
                    
                    const hoverMultiplier = 1 + (4 * maxBrightnessInfluence);
                    const waveBrightness = waveEffect.brightness;
                    const totalBrightnessBoost = Math.max(hoverMultiplier - 1, waveBrightness);
                    brightness = Math.min(255, Math.floor(ambientBrightness * (1 + totalBrightnessBoost) * 255));
                } else {
                    const returnSpeed = 0.02;
                    dot.currentX += (dot.baseX - dot.currentX) * returnSpeed;
                    dot.currentY += (dot.baseY - dot.currentY) * returnSpeed;
                    brightness = Math.floor(ambientBrightness * 255);
                }
                
                if (!brightnessBuckets.has(brightness)) {
                    brightnessBuckets.set(brightness, []);
                }
                brightnessBuckets.get(brightness).push(dot);
            });
            
            brightnessBuckets.forEach((dotsGroup, brightness) => {
                ctx.strokeStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx.beginPath();
                
                dotsGroup.forEach(dot => {
                    ctx.moveTo(dot.currentX - CROSS_SIZE, dot.currentY);
                    ctx.lineTo(dot.currentX + CROSS_SIZE, dot.currentY);
                    ctx.moveTo(dot.currentX, dot.currentY - CROSS_SIZE);
                    ctx.lineTo(dot.currentX, dot.currentY + CROSS_SIZE);
                });
                
                ctx.stroke();
            });
            
            // Draw text with gradient fill based on hover proximity
            textElements.forEach(element => {
                drawTextWithGradient(element, seeds, mx, my);
            });
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Event Handlers
        function handleMouseMove(e) {
            mousePos = { x: e.clientX, y: e.clientY };
            isHovering = true;
        }
        
        function handleMouseLeave() {
            isHovering = false;
        }
        
        function handleClick(e) {
            console.log('Click detected at:', e.clientX, e.clientY); // Debug
            // Create expanding wave at click position
            waves.push({
                x: e.clientX,
                y: e.clientY,
                radius: 0,
                speed: 8 / globalScaleFactor, // Pixels per frame
                intensity: 1.0,
                decay: 0.97 // Decay factor per frame
            });
            console.log('Wave created, total waves:', waves.length); // Debug
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                mousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                isHovering = true;
                
                // Also create wave on touch
                waves.push({
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY,
                    radius: 0,
                    speed: 8 / globalScaleFactor,
                    intensity: 1.0,
                    decay: 0.97
                });
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                mousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                isHovering = true;
            }
        }
        
        function handleTouchEnd() {
            isHovering = false;
        }
        
        // Initialize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseleave', handleMouseLeave);
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);
        
        animationId = requestAnimationFrame(animate);
    </script>
</body>
</html>


